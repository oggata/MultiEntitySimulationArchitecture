<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ëá™Âæã„Ç®„Éº„Ç∏„Çß„É≥„Éà„Éª„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ with AI</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            max-width: 250px;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.95);
            padding: 15px;
            border-radius: 8px;
            max-width: 280px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        #info-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #info-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        #info-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .panel-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 6px;
            margin: 6px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 12px;
        }
        
        button {
            padding: 6px 12px;
            margin: 6px 0;
            cursor: pointer;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .agent-card {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .agent-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .agent-name {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .agent-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .status-active {
            background: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .agent-info-row {
            margin: 3px 0;
            font-size: 12px;
            color: #b0b0b0;
        }
        
        .agent-thought {
            font-style: italic;
            color: #80cbc4;
            margin-top: 6px;
            padding: 6px;
            background: rgba(128, 203, 196, 0.1);
            border-radius: 4px;
            border-left: 3px solid #80cbc4;
            font-size: 12px;
        }
        
        .agent-memory {
            margin-top: 6px;
            font-size: 11px;
        }
        
        .memory-item {
            padding: 3px 6px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 3px;
            color: #888;
        }
        
        .relationship-info {
            margin-top: 6px;
            font-size: 11px;
        }
        
        .relationship-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 4px 0;
        }
        
        .relationship-bar {
            width: 100px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .relationship-fill {
            height: 100%;
            background: linear-gradient(to right, #ff6b6b, #ffd93d, #6bcf7f);
            transition: width 0.3s ease;
        }
        
        #log-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            padding: 12px;
            border-radius: 8px;
            max-width: 350px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .log-entry {
            margin: 6px 0;
            padding: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            font-size: 11px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .log-thought {
            border-left-color: #80cbc4;
            color: #80cbc4;
        }
        
        .log-interaction {
            border-left-color: #FFC107;
            color: #FFC107;
        }
        
        .log-movement {
            border-left-color: #2196F3;
            color: #2196F3;
        }
        
        .time-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.95);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 13px;
            color: #4CAF50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .warning {
            color: #ff9800;
            font-size: 11px;
            margin-top: 8px;
            padding: 8px;
            background: rgba(255, 152, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        /* „É≠„Éº„Éá„Ç£„É≥„Ç∞„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
        .thinking-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 1.5s infinite;
            margin-left: 8px;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        .log-entry {
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            font-size: 13px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .log-thought {
            border-left-color: #80cbc4;
            color: #80cbc4;
        }
        
        .log-interaction {
            border-left-color: #FFC107;
            color: #FFC107;
        }
        
        .log-movement {
            border-left-color: #2196F3;
            color: #2196F3;
        }
        
        .log-relationship {
            border-left-color: #E91E63;
            color: #E91E63;
        }
        
        .log-details-toggle {
            margin-top: 5px;
            cursor: pointer;
            color: #888;
            font-size: 12px;
        }
        
        .log-details-toggle:hover {
            color: #fff;
        }
        
        .log-details {
            margin-top: 6px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 3px;
            font-size: 11px;
        }
        
        .log-detail-section {
            margin-bottom: 6px;
        }
        
        .log-detail-section h4 {
            margin: 0 0 4px 0;
            color: #4CAF50;
            font-size: 11px;
        }
        
        .agent-name {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .relationship-change {
            color: #E91E63;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="time-display" id="time-display">
        ÂçàÂâç 8:00
    </div>
    
    <div id="control-panel">
        <h3 class="panel-title">üîß Âà∂Âæ°„Éë„Éç„É´</h3>
        <input type="password" id="apiKey" placeholder="OpenAI API„Ç≠„Éº„ÇíÂÖ•Âäõ">
        <button onclick="startSimulation()">„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÈñãÂßã</button>
        <button onclick="pauseSimulation()" id="pauseBtn" disabled>‰∏ÄÊôÇÂÅúÊ≠¢</button>
        <button onclick="setTimeSpeed()">ÊôÇÈñìÈÄüÂ∫¶: <span id="speed">1x</span></button>
        <div class="warning">
            ‚ö†Ô∏è API„Ç≠„Éº„ÅØ„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò„Åï„Çå„Åæ„Åõ„Çì„ÄÇ<br>
            ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„ÄÅ„Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Çµ„Éº„Éê„ÉºÁµåÁî±„ÅßAPI„ÇíÂëº„Å≥Âá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
        </div>
    </div>
    
    <div id="info-panel">
        <h3 class="panel-title">üë• „Ç®„Éº„Ç∏„Çß„É≥„ÉàÊÉÖÂ†±</h3>
        <div id="agents-list"></div>
    </div>
    
    <div id="log-panel">
        <h3 class="panel-title">üìù Ê¥ªÂãï„É≠„Ç∞</h3>
        <div id="activity-log"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
        let scene, camera, renderer;
        let agents = [];
        let locations = [];
        let apiKey = '';
        let simulationRunning = false;
        let simulationPaused = false;
        let timeSpeed = 1;
        let currentTime = 8 * 60; // 8:00 AM in minutes
        const clock = new THREE.Clock();
        
        // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆË©≥Á¥∞„Å™ÊÄßÊ†ºË®≠ÂÆö
        const agentPersonalities = [
            {
                name: "Áî∞‰∏≠Â§™ÈÉé",
                age: 35,
                personality: {
                    description: "Ë¶™Âàá„ÅßÁ§æ‰∫§ÁöÑ„Å™‰ºöÁ§æÂì°„ÄÇ„Ç≥„Éº„Éí„Éº„ÅåÂ•Ω„Åç„Åß„ÄÅÊúù„ÅØ„Ç´„Éï„Çß„Åß‰∏ÄÊó•„ÇíÂßã„ÇÅ„Çã„ÄÇ",
                    traits: {
                        sociability: 0.9,      // Á§æ‰∫§ÊÄßÔºà0-1Ôºâ
                        energy: 0.7,           // Ê¥ªÂãïÁöÑ„Åï
                        routine: 0.8,          // „É´„Éº„ÉÅ„É≥ÈáçË¶ñÂ∫¶
                        curiosity: 0.6,        // Â•ΩÂ•áÂøÉ
                        empathy: 0.9          // ÂÖ±ÊÑüÊÄß
                    }
                },
                color: 0x4CAF50,
                dailyRoutine: {
                    morning: ["„Ç´„Éï„Çß", "Áî∫„ÅÆÂ∫ÉÂ†¥"],
                    afternoon: ["Âõ≥Êõ∏È§®", "ÂÖ¨Âúí"],
                    evening: ["„Ç´„Éï„Çß", "Áî∫„ÅÆÂ∫ÉÂ†¥"],
                    night: ["Ëá™ÂÆÖ"]
                },
                home: {
                    name: "Áî∞‰∏≠Â§™ÈÉé„ÅÆÂÆ∂",
                    x: -15,
                    z: -15,
                    color: 0x4CAF50
                }
            },
            {
                name: "Â±±Áî∞Ëä±Â≠ê",
                age: 28,
                personality: {
                    description: "ÂâµÈÄ†ÁöÑ„Å™„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„ÄÇÂÖ¨Âúí„ÅßÁµµ„ÇíÊèè„Åè„ÅÆ„ÅåÂ•Ω„Åç„ÄÇÁã¨Ëá™„ÅÆ‰∏ñÁïåË¶≥„ÇíÊåÅ„Å§„ÄÇ",
                    traits: {
                        sociability: 0.5,
                        energy: 0.6,
                        routine: 0.3,
                        curiosity: 0.9,
                        empathy: 0.8
                    }
                },
                color: 0xFF6B6B,
                dailyRoutine: {
                    morning: ["ÂÖ¨Âúí"],
                    afternoon: ["ÂÖ¨Âúí", "„Ç´„Éï„Çß"],
                    evening: ["Âõ≥Êõ∏È§®", "Áî∫„ÅÆÂ∫ÉÂ†¥"],
                    night: ["Ëá™ÂÆÖ"]
                },
                home: {
                    name: "Â±±Áî∞Ëä±Â≠ê„ÅÆÂÆ∂",
                    x: 15,
                    z: -15,
                    color: 0xFF6B6B
                }
            },
            {
                name: "‰ΩêËó§Ê¨°ÈÉé",
                age: 22,
                personality: {
                    description: "ÂÜÖÂêëÁöÑ„Å™Â§ßÂ≠¶Áîü„ÄÇÂõ≥Êõ∏È§®„ÅßÂãâÂº∑„Åô„Çã„Åì„Å®„ÅåÂ§ö„ÅÑ„ÄÇÊñ∞„Åó„ÅÑÁü•Ë≠ò„ÇíÊ±Ç„ÇÅ„Å¶„ÅÑ„Çã„ÄÇ",
                    traits: {
                        sociability: 0.3,
                        energy: 0.5,
                        routine: 0.7,
                        curiosity: 0.8,
                        empathy: 0.6
                    }
                },
                color: 0x4ECDC4,
                dailyRoutine: {
                    morning: ["Âõ≥Êõ∏È§®"],
                    afternoon: ["Âõ≥Êõ∏È§®", "„Ç´„Éï„Çß"],
                    evening: ["Áî∫„ÅÆÂ∫ÉÂ†¥", "Âõ≥Êõ∏È§®"],
                    night: ["Ëá™ÂÆÖ"]
                },
                home: {
                    name: "‰ΩêËó§Ê¨°ÈÉé„ÅÆÂÆ∂",
                    x: -15,
                    z: 15,
                    color: 0x4ECDC4
                }
            },
            {
                name: "Èà¥Êú®ÁæéÈ¶ô",
                age: 26,
                personality: {
                    description: "Ê¥ªÁô∫„Åß„Çπ„Éù„Éº„ÉÑÂ•Ω„Åç„ÄÇÊúù„ÅÆ„É©„É≥„Éã„É≥„Ç∞„ÅåÊó•Ë™≤„ÄÇ‰∫∫„Å®„ÅÆ‰∫§ÊµÅ„ÇíÊ•Ω„Åó„ÇÄ„ÄÇ",
                    traits: {
                        sociability: 0.8,
                        energy: 0.95,
                        routine: 0.9,
                        curiosity: 0.7,
                        empathy: 0.7
                    }
                },
                color: 0xFFE66D,
                dailyRoutine: {
                    morning: ["„Çπ„Éù„Éº„ÉÑ„Ç∏„É†", "ÂÖ¨Âúí"],
                    afternoon: ["„Ç´„Éï„Çß", "Áî∫„ÅÆÂ∫ÉÂ†¥"],
                    evening: ["„Çπ„Éù„Éº„ÉÑ„Ç∏„É†", "ÂÖ¨Âúí"],
                    night: ["Ëá™ÂÆÖ"]
                },
                home: {
                    name: "Èà¥Êú®ÁæéÈ¶ô„ÅÆÂÆ∂",
                    x: 15,
                    z: 15,
                    color: 0xFFE66D
                }
            },
            {
                name: "È´òÊ©ãÂÅ•‰∏Ä",
                age: 65,
                personality: {
                    description: "„ÅÆ„Çì„Å≥„Çä„Åó„ÅüÊÄßÊ†º„ÅÆÂπ¥ÈÖçËÄÖ„ÄÇ„Ç´„Éï„Çß„Åß„Åè„Å§„Çç„Åé„ÄÅËã•„ÅÑ‰∫∫„Å®„ÅÆ‰ºöË©±„ÇíÊ•Ω„Åó„ÇÄ„ÄÇ",
                    traits: {
                        sociability: 0.7,
                        energy: 0.3,
                        routine: 0.9,
                        curiosity: 0.5,
                        empathy: 0.95
                    }
                },
                color: 0xA8E6CF,
                dailyRoutine: {
                    morning: ["„Ç´„Éï„Çß", "Áî∫„ÅÆÂ∫ÉÂ†¥"],
                    afternoon: ["ÂÖ¨Âúí", "„Ç´„Éï„Çß"],
                    evening: ["Áî∫„ÅÆÂ∫ÉÂ†¥", "„Ç´„Éï„Çß"],
                    night: ["Ëá™ÂÆÖ"]
                },
                home: {
                    name: "È´òÊ©ãÂÅ•‰∏Ä„ÅÆÂÆ∂",
                    x: 0,
                    z: -20,
                    color: 0xA8E6CF
                }
            }
        ];
        
        // Â†¥ÊâÄ„ÅÆË©≥Á¥∞Ë®≠ÂÆö
        const locationData = [
            {
                name: "„Ç´„Éï„Çß",
                x: -10,
                z: -10,
                color: 0x8B4513,
                activities: ["„Ç≥„Éº„Éí„Éº„ÇíÈ£≤„ÇÄ", "‰ºöË©±„Åô„Çã", "Ë™≠Êõ∏„Åô„Çã", "‰ªï‰∫ã„Çí„Åô„Çã"],
                atmosphere: "ËêΩ„Å°ÁùÄ„ÅÑ„ÅüÈõ∞Âõ≤Ê∞ó„Åß„ÄÅ„Ç≥„Éº„Éí„Éº„ÅÆÈ¶ô„Çä„ÅåÊºÇ„ÅÜ"
            },
            {
                name: "ÂÖ¨Âúí",
                x: 10,
                z: -10,
                color: 0x228B22,
                activities: ["Êï£Ê≠©„Åô„Çã", "Áµµ„ÇíÊèè„Åè", "„Éô„É≥„ÉÅ„Åß‰ºë„ÇÄ", "ÈÅãÂãï„Åô„Çã"],
                atmosphere: "Á∑ëË±ä„Åã„ÅßÈñãÊîæÁöÑ„Å™Á©∫Èñì"
            },
            {
                name: "Âõ≥Êõ∏È§®",
                x: -10,
                z: 10,
                color: 0x4682B4,
                activities: ["ÂãâÂº∑„Åô„Çã", "Êú¨„ÇíË™≠„ÇÄ", "Ë™ø„ÅπÁâ©„Çí„Åô„Çã", "Èùô„Åã„Å´ÈÅé„Åî„Åô"],
                atmosphere: "ÈùôÂØÇ„Å´ÂåÖ„Åæ„Çå„ÅüÁü•Ë≠ò„ÅÆÂÆùÂ∫´"
            },
            {
                name: "„Çπ„Éù„Éº„ÉÑ„Ç∏„É†",
                x: 10,
                z: 10,
                color: 0xFF6347,
                activities: ["ÈÅãÂãï„Åô„Çã", "Á≠ã„Éà„É¨„Åô„Çã", "„É®„Ç¨„Çí„Åô„Çã", "‰ªñ„ÅÆ‰∫∫„Å®ÈÅãÂãï„ÅÆË©±„Çí„Åô„Çã"],
                atmosphere: "Ê¥ªÊ∞ó„Åå„ÅÇ„Çä„ÄÅ„Ç®„Éç„É´„ÇÆ„ÉÉ„Ç∑„É•„Å™Â†¥ÊâÄ"
            },
            {
                name: "Áî∫„ÅÆÂ∫ÉÂ†¥",
                x: 0,
                z: 0,
                color: 0xDAA520,
                activities: ["‰∫∫„ÄÖ„ÇíË¶≥ÂØü„Åô„Çã", "ÂæÖ„Å°Âêà„Çè„Åõ„Åô„Çã", "„Ç§„Éô„É≥„Éà„Å´ÂèÇÂä†„Åô„Çã", "‰ºëÊÜ©„Åô„Çã"],
                atmosphere: "Áî∫„ÅÆ‰∏≠ÂøÉ„Åß„ÄÅÊßò„ÄÖ„Å™‰∫∫„ÅåË°å„Åç‰∫§„ÅÜ"
            }
        ];
        
        // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÇØ„É©„ÇπÔºàÊã°ÂºµÁâàÔºâ
        class Agent {
            constructor(data, index) {
                this.name = data.name;
                this.age = data.age;
                this.personality = data.personality;
                this.dailyRoutine = data.dailyRoutine;
                this.currentLocation = locations[index % locations.length];
                this.targetLocation = this.currentLocation;
                
                // Ë®òÊÜ∂„Ç∑„Çπ„ÉÜ„É†
                this.shortTermMemory = [];  // Áü≠ÊúüË®òÊÜ∂ÔºàÊúÄËøë„ÅÆÂá∫Êù•‰∫ãÔºâ
                this.longTermMemory = [];   // Èï∑ÊúüË®òÊÜ∂ÔºàÈáçË¶Å„Å™Âá∫Êù•‰∫ãÔºâ
                this.relationships = new Map(); // ‰ªñ„ÅÆ„Ç®„Éº„Ç∏„Çß„É≥„Éà„Å®„ÅÆÈñ¢‰øÇÊÄß
                
                // ÁèæÂú®„ÅÆÁä∂ÊÖã
                this.currentThought = "‰∏ÄÊó•„ÇíÂßã„ÇÅ„Å¶„ÅÑ„Åæ„Åô...";
                this.currentActivity = null;
                this.mood = "ÊôÆÈÄö";
                this.energy = 1.0;
                this.isThinking = false;
                
                // „Çø„Ç§„Éü„É≥„Ç∞Âà∂Âæ°
                this.lastActionTime = Date.now();
                this.lastThoughtTime = Date.now();
                this.thinkingDuration = 5000 + Math.random() * 10000; // 5-15Áßí
                
                // 3D„É¢„Éá„É´
                this.createModel(data.color);
                
                // ÁßªÂãïÈñ¢ÈÄ£
                this.speed = 0.03 + (this.personality.traits.energy * 0.02);
                this.movementTarget = null;
                
                // ‰ªñ„ÅÆ„Ç®„Éº„Ç∏„Çß„É≥„Éà„Å®„ÅÆÈñ¢‰øÇ„ÇíÂàùÊúüÂåñ
                this.initializeRelationships();
            }
            
            createModel(color) {
                const group = new THREE.Group();
                
                // ‰ΩìÔºàÂÜÜÊü±Ôºâ
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                bodyMesh.position.y = 0.5;
                bodyMesh.castShadow = true;
                group.add(bodyMesh);
                
                // È†≠ÔºàÁêÉ‰ΩìÔºâ
                const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
                const headMaterial = new THREE.MeshLambertMaterial({ color: color });
                const headMesh = new THREE.Mesh(headGeometry, headMaterial);
                headMesh.position.y = 1.25;
                headMesh.castShadow = true;
                group.add(headMesh);
                
                // ÊÄùËÄÉ‰∏≠„Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºÔºàÈ†≠„ÅÆ‰∏ä„ÅÆÂ∞è„Åï„Å™ÁêÉÔºâ
                const thinkingGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const thinkingMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                this.thinkingIndicator = new THREE.Mesh(thinkingGeometry, thinkingMaterial);
                this.thinkingIndicator.position.y = 1.8;
                this.thinkingIndicator.visible = false;
                group.add(this.thinkingIndicator);
                
                this.mesh = group;
                this.mesh.position.copy(this.currentLocation.position);
                this.mesh.position.y = 0;
                scene.add(this.mesh);
            }
            
            initializeRelationships() {
                // ‰ªñ„ÅÆ„Ç®„Éº„Ç∏„Çß„É≥„Éà„Å®„ÅÆÂàùÊúüÈñ¢‰øÇÂÄ§„ÇíË®≠ÂÆö
                agentPersonalities.forEach(other => {
                    if (other.name !== this.name) {
                        this.relationships.set(other.name, {
                            familiarity: Math.random() * 0.3, // 0-0.3„ÅÆÂàùÊúüÂÄ§
                            affinity: 0.5, // ‰∏≠Á´ãÁöÑ„Å™Èñ¢‰øÇ„Åã„ÇâÈñãÂßã
                            lastInteraction: null,
                            interactionCount: 0
                        });
                    }
                });
            }
            
            async update(deltaTime) {
                // „Ç®„Éç„É´„ÇÆ„Éº„ÅÆÊõ¥Êñ∞ÔºàÊôÇÈñì„Å®„Å®„ÇÇ„Å´Ê∏õÂ∞ëÔºâ
                this.energy = Math.max(0.1, this.energy - (deltaTime * 0.0001));
                
                // Â§úÈñì„ÅØËá™ÂÆÖ„Åß„Ç®„Éç„É´„ÇÆ„Éº„ÇíÂõûÂæ©
                if (this.getTimeOfDay() === "night" && this.currentLocation.name === this.home.name) {
                    this.energy = Math.min(1.0, this.energy + (deltaTime * 0.0002));
                }
                
                // ÁßªÂãïÂá¶ÁêÜ
                if (this.movementTarget) {
                    const direction = new THREE.Vector3()
                        .subVectors(this.movementTarget, this.mesh.position)
                        .normalize();
                    
                    const distance = this.mesh.position.distanceTo(this.movementTarget);
                    
                    if (distance > 0.5) {
                        const currentSpeed = this.speed * this.energy;
                        this.mesh.position.add(direction.multiplyScalar(currentSpeed));
                        this.mesh.position.y = 0;
                    } else if (this.targetLocation) {
                        // ÁõÆÁöÑÂú∞„Å´Âà∞ÁùÄ
                        this.currentLocation = this.targetLocation;
                        this.movementTarget = null;
                        this.onArrival();
                    }
                }
                
                // ÊÄùËÄÉ‰∏≠„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                if (this.isThinking && this.thinkingIndicator) {
                    this.thinkingIndicator.visible = true;
                    this.thinkingIndicator.position.y = 1.8 + Math.sin(Date.now() * 0.003) * 0.1;
                    this.thinkingIndicator.rotation.y += deltaTime * 2;
                } else {
                    this.thinkingIndicator.visible = false;
                }
                
                // ÂÆöÊúüÁöÑ„Å™ÊÄùËÄÉ„Éó„É≠„Çª„Çπ
                if (Date.now() - this.lastThoughtTime > this.thinkingDuration && !this.isThinking) {
                    this.think();
                }
            }
            
            async think() {
                if (!apiKey || !simulationRunning || simulationPaused) return;
                
                this.isThinking = true;
                const timeOfDay = this.getTimeOfDay();
                const nearbyAgents = this.getNearbyAgents();
                
                try {
                    // ÊÄùËÄÉ„Éó„É≠„É≥„Éó„Éà„ÅÆÊßãÁØâ
                    const prompt = this.buildThoughtPrompt(timeOfDay, nearbyAgents);
                    
                    // „Éá„É¢Áî®„ÅÆÊÄùËÄÉ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÔºàÂÆüÈöõ„ÅÆAPIÂëº„Å≥Âá∫„Åó„ÅÆ‰ª£„Çè„ÇäÔºâ
                    const decision = await this.simulateThought(prompt, timeOfDay, nearbyAgents);
                    
                    // Ê±∫ÂÆö„Å´Âü∫„Å•„ÅÑ„Å¶Ë°åÂãï
                    this.executeDecision(decision);
                    
                    logAgentAction(this, 'think', `
                        <div class="log-detail-section">
                            <h4>ÊÄùËÄÉ„ÅÆË©≥Á¥∞</h4>
                            <p>ÊôÇÈñìÂ∏Ø: ${timeOfDay}</p>
                            <p>Â†¥ÊâÄ: ${this.currentLocation.name}</p>
                            <p>Ëøë„Åè„ÅÆ„Ç®„Éº„Ç∏„Çß„É≥„Éà: ${nearbyAgents.map(a => a.name).join(', ') || '„Å™„Åó'}</p>
                            <p>ÊÄùËÄÉÂÜÖÂÆπ: ${this.currentThought}</p>
                        </div>
                    `);
                    
                } catch (error) {
                    console.error(`${this.name}„ÅÆÊÄùËÄÉ„Éó„É≠„Çª„Çπ„Ç®„É©„Éº:`, error);
                } finally {
                    this.isThinking = false;
                    this.lastThoughtTime = Date.now();
                    this.thinkingDuration = 10000 + Math.random() * 20000; // 10-30Áßí
                }
            }
            
            buildThoughtPrompt(timeOfDay, nearbyAgents) {
                const recentMemories = this.shortTermMemory.slice(-5).map(m => m.event).join(', ');
                const currentMood = this.calculateMood();
                
                return `
                ÁßÅ„ÅØ${this.name}„ÄÅ${this.age}Ê≠≥„ÄÇ${this.personality.description}
                
                ÁèæÂú®„ÅÆÁä∂Ê≥Å:
                - ÊôÇÈñìÂ∏Ø: ${timeOfDay}ÔºàÂ§úÈñì„ÅØ22:00-6:00Ôºâ
                - ÁèæÂú®Âú∞: ${this.currentLocation.name}Ôºà${this.currentLocation.atmosphere}Ôºâ
                - ‰ΩìÂäõ: ${Math.round(this.energy * 100)}%
                - Ê∞óÂàÜ: ${currentMood}
                - ÊúÄËøë„ÅÆÂá∫Êù•‰∫ã: ${recentMemories || '„Å™„Åó'}
                
                ${nearbyAgents.length > 0 ? `Ëøë„Åè„Å´„ÅÑ„Çã‰∫∫: ${nearbyAgents.map(a => a.name).join(', ')}` : ''}
                
                ÁßÅ„ÅÆÊÄßÊ†ºÁâπÊÄß:
                - Á§æ‰∫§ÊÄß: ${this.personality.traits.sociability}
                - Ê¥ªÂãïÁöÑ„Åï: ${this.personality.traits.energy}
                - „É´„Éº„ÉÅ„É≥ÈáçË¶ñ: ${this.personality.traits.routine}
                - Â•ΩÂ•áÂøÉ: ${this.personality.traits.curiosity}
                
                ÈáçË¶Å„Å™Ë°åÂãï„É´„Éº„É´:
                1. Â§úÈñìÔºà22:00-6:00Ôºâ„ÅØÂøÖ„ÅöËá™ÂÆÖ„Å´Â∏∞„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô
                2. Â§úÈñì„ÅØËá™ÂÆÖ‰ª•Â§ñ„ÅÆÂ†¥ÊâÄ„Å´Èï∑„ÅèÁïô„Åæ„Çâ„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ
                3. Â§úÈñì„ÅØ‰ΩìÂäõ„ÇíÂõûÂæ©„Åô„Çã„Åü„ÇÅ„Å´Ëá™ÂÆÖ„Åß‰ºë„ÇÄ„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô
                
                „Åì„ÅÆÁä∂Ê≥Å„Åß„ÄÅÊ¨°„Å´‰Ωï„Çí„Åó„Åü„ÅÑ„Åß„Åô„ÅãÔºü„Å©„ÅÆ„Çà„ÅÜ„Å´ÊÑü„Åò„Å¶„ÅÑ„Åæ„Åô„ÅãÔºü
                Áâπ„Å´Â§úÈñì„ÅÆÂ†¥Âêà„ÅØ„ÄÅËá™ÂÆÖ„Å´Â∏∞„Çã„Åì„Å®„ÇíÂÑ™ÂÖà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                `;
            }
            
            async simulateThought(prompt, timeOfDay, nearbyAgents) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: "gpt-3.5-turbo",
                            messages: [
                                {
                                    role: "system",
                                    content: "„ÅÇ„Å™„Åü„ÅØËá™ÂæãÁöÑ„Å™„Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆÊÑèÊÄùÊ±∫ÂÆö„Ç∑„Çπ„ÉÜ„É†„Åß„Åô„ÄÇ‰∏é„Åà„Çâ„Çå„ÅüÁä∂Ê≥Å„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅËá™ÁÑ∂„Å™Ë°åÂãï„Å®ÊÄùËÄÉ„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÁâπ„Å´Â§úÈñìÔºà22:00-6:00Ôºâ„ÅØÂøÖ„ÅöËá™ÂÆÖ„Å´Â∏∞„Çã„Åì„Å®„ÇíÂÑ™ÂÖà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 150
                        })
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error?.message || 'APIÂëº„Å≥Âá∫„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                    }

                    const aiResponse = data.choices[0].message.content;
                    
                    // AI„ÅÆÂøúÁ≠î„ÇíËß£Êûê„Åó„Å¶Ê±∫ÂÆö„ÇíÁîüÊàê
                    const decision = {
                        action: null,
                        thought: aiResponse,
                        targetLocation: null,
                        targetAgent: null
                    };

                    // Â§úÈñì„ÅÆÂ†¥Âêà„ÅØÂøÖ„ÅöËá™ÂÆÖ„Å´Â∏∞„Çã
                    if (timeOfDay === "night" && this.currentLocation.name !== this.home.name) {
                        const homeLocation = locations.find(l => l.name === this.home.name);
                        if (homeLocation) {
                            decision.action = "move";
                            decision.targetLocation = homeLocation;
                            decision.thought = "Â§ú„Å´„Å™„Å£„Åü„ÅÆ„Åß„ÄÅËá™ÂÆÖ„Å´Â∏∞„Çä„Åæ„Åô„ÄÇ";
                            return decision;
                        }
                    }

                    // ÊôÇÈñìÂ∏Ø„Å´Âü∫„Å•„Åè„É´„Éº„ÉÅ„É≥„ÅÆÁ¢∫Ë™ç
                    const routineLocation = this.getRoutineLocation(timeOfDay);
                    const shouldFollowRoutine = Math.random() < this.personality.traits.routine;

                    // Á§æ‰∫§ÁöÑ„Å™Ë°åÂãï„ÅÆÊ±∫ÂÆö
                    if (nearbyAgents.length > 0 && Math.random() < this.personality.traits.sociability) {
                        const targetAgent = nearbyAgents[Math.floor(Math.random() * nearbyAgents.length)];
                        const relationship = this.relationships.get(targetAgent.name);
                        
                        if (relationship && relationship.affinity > 0.3) {
                            decision.action = "interact";
                            decision.targetAgent = targetAgent;
                        }
                    }

                    // ÁßªÂãï„ÅÆÊ±∫ÂÆö
                    if (!decision.action) {
                        if (shouldFollowRoutine && routineLocation && routineLocation !== this.currentLocation.name) {
                            const targetLoc = locations.find(l => l.name === routineLocation);
                            if (targetLoc) {
                                decision.action = "move";
                                decision.targetLocation = targetLoc;
                            }
                        } else if (Math.random() < this.personality.traits.curiosity) {
                            const randomLocation = locations[Math.floor(Math.random() * locations.length)];
                            if (randomLocation !== this.currentLocation) {
                                decision.action = "move";
                                decision.targetLocation = randomLocation;
                            }
                        }
                    }

                    // ÁèæÂú®Âú∞„Åß„ÅÆÊ¥ªÂãï
                    if (!decision.action && this.currentLocation.activities.length > 0) {
                        const activity = this.currentLocation.activities[
                            Math.floor(Math.random() * this.currentLocation.activities.length)
                        ];
                        decision.action = "activity";
                        this.currentActivity = activity;
                    }

                    return decision;

                } catch (error) {
                    console.error('OpenAI APIÂëº„Å≥Âá∫„Åó„Ç®„É©„Éº:', error);
                    // „Ç®„É©„ÉºÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ
                    return {
                        action: null,
                        thought: "ËÄÉ„Åà‰∏≠...",
                        targetLocation: null,
                        targetAgent: null
                    };
                }
            }
            
            executeDecision(decision) {
                this.currentThought = decision.thought;
                
                // ÊÄùËÄÉ„Çí„É≠„Ç∞„Å´ËøΩÂä†
                addLog(decision.thought, 'thought');
                
                // Ë®òÊÜ∂„Å´ËøΩÂä†
                this.addMemory(decision.thought, "thought");
                
                switch (decision.action) {
                    case "move":
                        if (decision.targetLocation) {
                            this.moveToLocation(decision.targetLocation);
                        }
                        break;
                    
                    case "interact":
                        if (decision.targetAgent) {
                            this.interactWith(decision.targetAgent);
                        }
                        break;
                    
                    case "activity":
                        this.performActivity();
                        break;
                }
            }
            
            moveToLocation(location) {
                this.targetLocation = location;
                this.movementTarget = new THREE.Vector3(
                    location.position.x + (Math.random() - 0.5) * 2,
                    0,
                    location.position.z + (Math.random() - 0.5) * 2
                );
                
                addLog(`üö∂ ${this.name}„Åå${location.name}„Å∏ÁßªÂãïÈñãÂßã`, 'move', `
                    <div class="log-detail-section">
                        <h4>ÁßªÂãï„ÅÆË©≥Á¥∞</h4>
                        <p>Âá∫Áô∫Âú∞: ${this.currentLocation.name}</p>
                        <p>ÁõÆÁöÑÂú∞: ${location.name}</p>
                        <p>ÁßªÂãïÈÄüÂ∫¶: ${this.speed.toFixed(2)}</p>
                    </div>
                `);
            }
            
            onArrival() {
                addLog(`üìç ${this.name}„Åå${this.currentLocation.name}„Å´Âà∞ÁùÄ`, 'arrival');
                
                // Âà∞ÁùÄÊôÇ„ÅÆÊ¥ªÂãï„ÇíÊ±∫ÂÆö
                if (this.currentLocation.activities.length > 0) {
                    const activity = this.currentLocation.activities[
                        Math.floor(Math.random() * this.currentLocation.activities.length)
                    ];
                    this.currentActivity = activity;
                    this.currentThought = `${activity}„Åì„Å®„Å´„Åó„Çà„ÅÜ`;
                }
            }
            
            interactWith(otherAgent) {
                const relationship = this.relationships.get(otherAgent.name);
                if (!relationship) return;
                
                // Áõ∏‰∫í‰ΩúÁî®„ÅÆÁ®ÆÈ°û„ÇíÊ±∫ÂÆö
                const interactionTypes = this.getInteractionTypes(relationship);
                const interaction = interactionTypes[Math.floor(Math.random() * interactionTypes.length)];
                
                // Áõ∏‰∫í‰ΩúÁî®„ÇíÂÆüË°å
                this.performInteraction(otherAgent, interaction);
                
                // Èñ¢‰øÇÊÄß„ÅÆÊõ¥Êñ∞
                const oldAffinity = relationship.affinity;
                relationship.familiarity = Math.min(1, relationship.familiarity + 0.1);
                relationship.affinity = Math.min(1, Math.max(0, relationship.affinity + (Math.random() - 0.3) * 0.2));
                
                if (Math.abs(relationship.affinity - oldAffinity) > 0.1) {
                    logRelationshipChange(this, otherAgent, 'interaction');
                }
                
                relationship.lastInteraction = new Date();
                relationship.interactionCount++;
                
                // Áõ∏ÊâãÂÅ¥„ÅÆÈñ¢‰øÇÊÄß„ÇÇÊõ¥Êñ∞
                const otherRelationship = otherAgent.relationships.get(this.name);
                if (otherRelationship) {
                    otherRelationship.familiarity = relationship.familiarity;
                    otherRelationship.affinity = relationship.affinity;
                    otherRelationship.lastInteraction = relationship.lastInteraction;
                    otherRelationship.interactionCount++;
                }
            }
            
            getInteractionTypes(relationship) {
                const types = [];
                
                if (relationship.familiarity < 0.3) {
                    types.push("Êå®Êã∂", "Ëá™Â∑±Á¥π‰ªã", "Â§©Ê∞ó„ÅÆË©±");
                } else if (relationship.familiarity < 0.7) {
                    types.push("ÈõëË´á", "ËøëÊ≥ÅÂ†±Âëä", "ÂÖ±ÈÄö„ÅÆË©±È°å");
                } else {
                    types.push("Ê∑±„ÅÑ‰ºöË©±", "Áõ∏Ë´á", "‰∏ÄÁ∑í„Å´Ê¥ªÂãï");
                }
                
                if (relationship.affinity > 0.7) {
                    types.push("ÂÜóË´á", "ÊÄù„ÅÑÂá∫Ë©±");
                } else if (relationship.affinity < 0.3) {
                    types.push("Áü≠„ÅÑ‰ºöË©±", "ÂΩ¢ÂºèÁöÑ„Å™Êå®Êã∂");
                }
                
                return types;
            }
            
            async performInteraction(otherAgent, interactionType) {
                try {
                    const prompt = `
                    „ÅÇ„Å™„Åü„ÅØ${this.name}„Å®„ÅÑ„ÅÜ${this.age}Ê≠≥„ÅÆ${this.personality.description}„Åß„Åô„ÄÇ
                    ÁèæÂú®${this.currentLocation.name}„Å´„ÅÑ„Å¶„ÄÅ${otherAgent.name}„Åï„Çì„Å®${interactionType}„Çí„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
                    
                    „ÅÇ„Å™„Åü„ÅÆÊÄßÊ†ºÁâπÊÄß:
                    - Á§æ‰∫§ÊÄß: ${this.personality.traits.sociability}
                    - Ê¥ªÂãïÁöÑ„Åï: ${this.personality.traits.energy}
                    - „É´„Éº„ÉÅ„É≥ÈáçË¶ñ: ${this.personality.traits.routine}
                    - Â•ΩÂ•áÂøÉ: ${this.personality.traits.curiosity}
                    - ÂÖ±ÊÑüÊÄß: ${this.personality.traits.empathy}
                    
                    Áõ∏Êâã„Å®„ÅÆÈñ¢‰øÇ:
                    - Ë¶™ÂØÜÂ∫¶: ${this.relationships.get(otherAgent.name).familiarity}
                    - Â•ΩÊÑüÂ∫¶: ${this.relationships.get(otherAgent.name).affinity}
                    
                    „Åì„ÅÆÁä∂Ê≥Å„Åß„ÄÅËá™ÁÑ∂„Å™‰ºöË©±„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ1-2ÊñáÁ®ãÂ∫¶„ÅÆÁü≠„ÅÑ‰ºöË©±„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                    `;

                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: "gpt-3.5-turbo",
                            messages: [
                                {
                                    role: "system",
                                    content: "„ÅÇ„Å™„Åü„ÅØËá™ÂæãÁöÑ„Å™„Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆ‰ºöË©±„Ç∑„Çπ„ÉÜ„É†„Åß„Åô„ÄÇ‰∏é„Åà„Çâ„Çå„ÅüÁä∂Ê≥Å„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅËá™ÁÑ∂„Å™‰ºöË©±„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 100
                        })
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error?.message || 'APIÂëº„Å≥Âá∫„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                    }

                    const message = data.choices[0].message.content;
                    
                    this.currentThought = message;
                    addLog(`üí¨ ${this.name} ‚Üí ${otherAgent.name}: "${message}"`, 'interaction');
                    
                    this.addMemory(`${otherAgent.name}„Å®${interactionType}„Çí„Åó„Åü`, "interaction");
                    
                    // Áõ∏Êâã„ÅÆÂèçÂøú
                    setTimeout(async () => {
                        if (otherAgent && !otherAgent.isThinking) {
                            const responsePrompt = `
                            „ÅÇ„Å™„Åü„ÅØ${otherAgent.name}„Å®„ÅÑ„ÅÜ${otherAgent.age}Ê≠≥„ÅÆ${otherAgent.personality.description}„Åß„Åô„ÄÇ
                            ${this.name}„Åï„Çì„Åã„Çâ„Äå${message}„Äç„Å®Ë®Ä„Çè„Çå„Åæ„Åó„Åü„ÄÇ
                            
                            „ÅÇ„Å™„Åü„ÅÆÊÄßÊ†ºÁâπÊÄß:
                            - Á§æ‰∫§ÊÄß: ${otherAgent.personality.traits.sociability}
                            - Ê¥ªÂãïÁöÑ„Åï: ${otherAgent.personality.traits.energy}
                            - „É´„Éº„ÉÅ„É≥ÈáçË¶ñ: ${otherAgent.personality.traits.routine}
                            - Â•ΩÂ•áÂøÉ: ${otherAgent.personality.traits.curiosity}
                            - ÂÖ±ÊÑüÊÄß: ${otherAgent.personality.traits.empathy}
                            
                            Áõ∏Êâã„Å®„ÅÆÈñ¢‰øÇ:
                            - Ë¶™ÂØÜÂ∫¶: ${otherAgent.relationships.get(this.name).familiarity}
                            - Â•ΩÊÑüÂ∫¶: ${otherAgent.relationships.get(this.name).affinity}
                            
                            „Åì„ÅÆÁä∂Ê≥Å„Åß„ÄÅËá™ÁÑ∂„Å™ËøîÁ≠î„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ1-2ÊñáÁ®ãÂ∫¶„ÅÆÁü≠„ÅÑËøîÁ≠î„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                            `;

                            try {
                                const responseResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${apiKey}`
                                    },
                                    body: JSON.stringify({
                                        model: "gpt-3.5-turbo",
                                        messages: [
                                            {
                                                role: "system",
                                                content: "„ÅÇ„Å™„Åü„ÅØËá™ÂæãÁöÑ„Å™„Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆ‰ºöË©±„Ç∑„Çπ„ÉÜ„É†„Åß„Åô„ÄÇ‰∏é„Åà„Çâ„Çå„ÅüÁä∂Ê≥Å„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅËá™ÁÑ∂„Å™ËøîÁ≠î„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                                            },
                                            {
                                                role: "user",
                                                content: responsePrompt
                                            }
                                        ],
                                        temperature: 0.7,
                                        max_tokens: 100
                                    })
                                });

                                const responseData = await responseResponse.json();
                                if (!responseResponse.ok) {
                                    throw new Error(responseData.error?.message || 'APIÂëº„Å≥Âá∫„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                                }

                                const responseMessage = responseData.choices[0].message.content;
                                otherAgent.currentThought = responseMessage;
                                addLog(`üí¨ ${otherAgent.name} ‚Üí ${this.name}: "${responseMessage}"`, 'interaction');
                            } catch (error) {
                                console.error('OpenAI APIÂëº„Å≥Âá∫„Åó„Ç®„É©„Éº:', error);
                                const fallbackResponses = [
                                    `${this.name}„Åï„Çì„ÄÅÁßÅ„ÇÇÂêå„Åò„Çà„ÅÜ„Å´ÊÄù„ÅÑ„Åæ„ÅôÔºÅ`,
                                    "„Å™„Çã„Åª„Å©„ÄÅ„Åù„ÅÜ„Åß„Åô„Å≠„ÄÇ",
                                    "„Åù„Çå„ÅØËààÂë≥Ê∑±„ÅÑË©±„Åß„Åô„Å≠„ÄÇ",
                                    `${this.name}„Åï„Çì„Å®„ÅäË©±„Åó„Åß„Åç„Å¶Â¨â„Åó„ÅÑ„Åß„Åô„ÄÇ`
                                ];
                                const fallbackResponse = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
                                otherAgent.currentThought = fallbackResponse;
                                addLog(`üí¨ ${otherAgent.name} ‚Üí ${this.name}: "${fallbackResponse}"`, 'interaction');
                            }
                        }
                    }, 2000);
                } catch (error) {
                    console.error('OpenAI APIÂëº„Å≥Âá∫„Åó„Ç®„É©„Éº:', error);
                    const fallbackMessages = {
                        "Êå®Êã∂": [
                            `${otherAgent.name}„Åï„Çì„ÄÅ„Åì„Çì„Å´„Å°„ÅØÔºÅ`,
                            `„ÇÑ„ÅÇ„ÄÅ${otherAgent.name}„Åï„Çì„ÄÇÂÖÉÊ∞óÔºü`,
                            `${otherAgent.name}„Åï„Çì„ÄÅ„Åä‰πÖ„Åó„Å∂„ÇäÔºÅ`
                        ],
                        "Ëá™Â∑±Á¥π‰ªã": [
                            `Âàù„ÇÅ„Åæ„Åó„Å¶„ÄÅ${this.name}„Å®Áî≥„Åó„Åæ„Åô„ÄÇ`,
                            `${this.personality.description.split('„ÄÇ')[0]}„Åß„Åô„ÄÇ`,
                            `„Çà„Çç„Åó„Åè„ÅäÈ°ò„ÅÑ„Åó„Åæ„ÅôÔºÅ`
                        ],
                        "Â§©Ê∞ó„ÅÆË©±": [
                            "‰ªäÊó•„ÅØ„ÅÑ„ÅÑÂ§©Ê∞ó„Åß„Åô„Å≠„ÄÇ",
                            "ÊúÄËøë„ÄÅÈÅé„Åî„Åó„ÇÑ„Åô„ÅÑÊ∞óÂÄô„Åß„Åô„Å≠„ÄÇ",
                            "„Åì„Çì„Å™Êó•„ÅØÂ§ñ„Å´„ÅÑ„Çã„Å®Ê∞óÊåÅ„Å°„ÅÑ„ÅÑ„Åß„Åô„Å≠„ÄÇ"
                        ]
                    };
                    
                    const messageList = fallbackMessages[interactionType] || ["..."];
                    const message = messageList[Math.floor(Math.random() * messageList.length)];
                    
                    this.currentThought = message;
                    addLog(`üí¨ ${this.name} ‚Üí ${otherAgent.name}: "${message}"`, 'interaction');
                }
            }
            
            async performActivity() {
                if (this.currentActivity) {
                    try {
                        const prompt = `
                        „ÅÇ„Å™„Åü„ÅØ${this.name}„Å®„ÅÑ„ÅÜ${this.age}Ê≠≥„ÅÆ${this.personality.description}„Åß„Åô„ÄÇ
                        ÁèæÂú®${this.currentLocation.name}„Åß${this.currentActivity}„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
                        
                        „ÅÇ„Å™„Åü„ÅÆÊÄßÊ†ºÁâπÊÄß:
                        - Á§æ‰∫§ÊÄß: ${this.personality.traits.sociability}
                        - Ê¥ªÂãïÁöÑ„Åï: ${this.personality.traits.energy}
                        - „É´„Éº„ÉÅ„É≥ÈáçË¶ñ: ${this.personality.traits.routine}
                        - Â•ΩÂ•áÂøÉ: ${this.personality.traits.curiosity}
                        - ÂÖ±ÊÑüÊÄß: ${this.personality.traits.empathy}
                        
                        „Åì„ÅÆÁä∂Ê≥Å„Åß„ÄÅ„ÅÇ„Å™„Åü„ÅåÊÑü„Åò„Å¶„ÅÑ„Çã„Åì„Å®„ÇÑËÄÉ„Åà„Å¶„ÅÑ„Çã„Åì„Å®„ÇíËá™ÁÑ∂„Å™ÂΩ¢„ÅßË°®Áèæ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                        1-2ÊñáÁ®ãÂ∫¶„ÅÆÁü≠„ÅÑÊÄùËÄÉ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                        `;

                        const response = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: "gpt-3.5-turbo",
                                messages: [
                                    {
                                        role: "system",
                                        content: "„ÅÇ„Å™„Åü„ÅØËá™ÂæãÁöÑ„Å™„Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆÊÄùËÄÉ„Ç∑„Çπ„ÉÜ„É†„Åß„Åô„ÄÇ‰∏é„Åà„Çâ„Çå„ÅüÁä∂Ê≥Å„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅËá™ÁÑ∂„Å™ÊÄùËÄÉ„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                                    },
                                    {
                                        role: "user",
                                        content: prompt
                                    }
                                ],
                                temperature: 0.7,
                                max_tokens: 100
                            })
                        });

                        const data = await response.json();
                        if (!response.ok) {
                            throw new Error(data.error?.message || 'APIÂëº„Å≥Âá∫„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                        }

                        const thought = data.choices[0].message.content;
                        this.currentThought = thought;
                        addLog(`üéØ ${this.name}„ÅØ${this.currentLocation.name}„Åß${this.currentActivity}„ÅÑ„Çã: "${thought}"`, 'activity', `
                            <div class="log-detail-section">
                                <h4>Ê¥ªÂãï„ÅÆË©≥Á¥∞</h4>
                                <p>Â†¥ÊâÄ: ${this.currentLocation.name}</p>
                                <p>Ê¥ªÂãï: ${this.currentActivity}</p>
                                <p>ÊÄùËÄÉ: ${this.currentThought}</p>
                            </div>
                        `);
                        this.addMemory(`${this.currentLocation.name}„Åß${this.currentActivity}`, "activity");
                    } catch (error) {
                        console.error('OpenAI APIÂëº„Å≥Âá∫„Åó„Ç®„É©„Éº:', error);
                        this.currentThought = `${this.currentActivity}„ÅÑ„Çã`;
                        addLog(`üéØ ${this.name}„ÅØ${this.currentLocation.name}„Åß${this.currentActivity}„ÅÑ„Çã`, 'activity');
                        this.addMemory(`${this.currentLocation.name}„Åß${this.currentActivity}`, "activity");
                    }
                }
            }
            
            addMemory(event, type) {
                const memory = {
                    time: new Date(),
                    event: event,
                    type: type,
                    location: this.currentLocation.name,
                    mood: this.mood
                };
                
                this.shortTermMemory.push(memory);
                
                // Áü≠ÊúüË®òÊÜ∂„ÅÆÂà∂ÈôêÔºàÊúÄÊñ∞20‰ª∂Ôºâ
                if (this.shortTermMemory.length > 20) {
                    const oldMemory = this.shortTermMemory.shift();
                    // ÈáçË¶Å„Å™Ë®òÊÜ∂„ÅØÈï∑ÊúüË®òÊÜ∂„Å∏
                    if (oldMemory.type === "interaction" || Math.random() < 0.3) {
                        this.longTermMemory.push(oldMemory);
                    }
                }
                
                // Èï∑ÊúüË®òÊÜ∂„ÅÆÂà∂ÈôêÔºàÊúÄÂ§ß50‰ª∂Ôºâ
                if (this.longTermMemory.length > 50) {
                    this.longTermMemory.shift();
                }
            }
            
            getNearbyAgents() {
                return agents.filter(agent => 
                    agent !== this && 
                    agent.currentLocation === this.currentLocation &&
                    this.mesh.position.distanceTo(agent.mesh.position) < 5
                );
            }
            
            getTimeOfDay() {
                const hour = Math.floor(currentTime / 60);
                if (hour < 6 || hour >= 22) return "night";
                if (hour < 12) return "morning";
                if (hour < 18) return "afternoon";
                return "evening";
            }
            
            getRoutineLocation(timeOfDay) {
                const routine = this.dailyRoutine[timeOfDay];
                if (routine && routine.length > 0) {
                    // Â§úÈñì„ÅØÂøÖ„ÅöËá™ÂÆÖ„Å´Â∏∞„Çã
                    if (timeOfDay === "night") {
                        return this.home.name;
                    }
                    return routine[Math.floor(Math.random() * routine.length)];
                }
                return null;
            }
            
            calculateMood() {
                if (this.energy < 0.3) return "Áñ≤„Çå„Å¶„ÅÑ„Çã";
                if (this.energy > 0.8) return "ÂÖÉÊ∞ó";
                
                const recentInteractions = this.shortTermMemory.filter(m => 
                    m.type === "interaction" && 
                    (new Date() - m.time) < 300000 // 5ÂàÜ‰ª•ÂÜÖ
                ).length;
                
                if (recentInteractions > 2) return "Á§æ‰∫§ÁöÑ";
                if (recentInteractions === 0 && this.personality.traits.sociability > 0.7) return "ÂØÇ„Åó„ÅÑ";
                
                return "ÊôÆÈÄö";
            }
        }
        
        // Three.js„ÅÆÂàùÊúüÂåñ
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            //scene.fog = new THREE.Fog(0x87CEEB, 30, 60);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 35);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // „É©„Ç§„ÉÜ„Ç£„É≥„Ç∞
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Âú∞Èù¢
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90EE90,
                emissive: 0x90EE90,
                emissiveIntensity: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
                        
            // Â†¥ÊâÄ„ÅÆ‰ΩúÊàê
            createLocations();
            
            // „Éû„Ç¶„Çπ„Ç≥„É≥„Éà„É≠„Éº„É´
            setupMouseControls();
            
            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
            animate();
        }
        
        // Â†¥ÊâÄ„ÅÆ‰ΩúÊàê
        function createLocations() {
            locationData.forEach(loc => {
                const locationGroup = new THREE.Group();
                
                // Âª∫Áâ©„ÅÆÂü∫Êú¨ÊßãÈÄ†
                const buildingGeometry = new THREE.BoxGeometry(6, 4, 6);
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: loc.color,
                    emissive: loc.color,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(0, 2, 0);
                building.castShadow = true;
                building.receiveShadow = true;
                locationGroup.add(building);

                // Â±ãÊ†π
                const roofGeometry = new THREE.ConeGeometry(4.5, 2, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    emissive: 0x8B4513,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 5, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                locationGroup.add(roof);

                // Â†¥ÊâÄÁâπÊúâ„ÅÆË£ÖÈ£æ
                switch(loc.name) {
                    case "„Ç´„Éï„Çß":
                        // „ÉÜ„Éº„Éñ„É´„Å®Ê§ÖÂ≠ê
                        for(let i = 0; i < 4; i++) {
                            const tableGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
                            const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const table = new THREE.Mesh(tableGeometry, tableMaterial);
                            table.position.set(
                                Math.cos(i * Math.PI/2) * 2,
                                0.05,
                                Math.sin(i * Math.PI/2) * 2
                            );
                            locationGroup.add(table);

                            // Ê§ÖÂ≠ê
                            const chairGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                            const chairMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const chair = new THREE.Mesh(chairGeometry, chairMaterial);
                            chair.position.set(
                                Math.cos(i * Math.PI/2) * 2.5,
                                0.2,
                                Math.sin(i * Math.PI/2) * 2.5
                            );
                            locationGroup.add(chair);
                        }
                        break;

                    case "ÂÖ¨Âúí":
                        // Êú®
                        for(let i = 0; i < 3; i++) {
                            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
                            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                            trunk.position.set(
                                Math.cos(i * Math.PI/1.5) * 2,
                                0.75,
                                Math.sin(i * Math.PI/1.5) * 2
                            );
                            locationGroup.add(trunk);

                            const leavesGeometry = new THREE.SphereGeometry(1, 8, 8);
                            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                            leaves.position.set(
                                Math.cos(i * Math.PI/1.5) * 2,
                                2,
                                Math.sin(i * Math.PI/1.5) * 2
                            );
                            locationGroup.add(leaves);
                        }

                        // „Éô„É≥„ÉÅ
                        const benchGeometry = new THREE.BoxGeometry(2, 0.2, 0.5);
                        const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                        const bench = new THREE.Mesh(benchGeometry, benchMaterial);
                        bench.position.set(0, 0.1, 2);
                        locationGroup.add(bench);
                        break;

                    case "Âõ≥Êõ∏È§®":
                        // Êú¨Ê£ö
                        for(let i = 0; i < 2; i++) {
                            const bookshelfGeometry = new THREE.BoxGeometry(0.3, 3, 2);
                            const bookshelfMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const bookshelf = new THREE.Mesh(bookshelfGeometry, bookshelfMaterial);
                            bookshelf.position.set(
                                i === 0 ? -2 : 2,
                                1.5,
                                0
                            );
                            locationGroup.add(bookshelf);
                        }
                        break;

                    case "„Çπ„Éù„Éº„ÉÑ„Ç∏„É†":
                        // „Éà„É¨„Éº„Éã„É≥„Ç∞„Éû„Ç∑„É≥
                        const machineGeometry = new THREE.BoxGeometry(1, 1, 2);
                        const machineMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                        const machine = new THREE.Mesh(machineGeometry, machineMaterial);
                        machine.position.set(0, 0.5, 0);
                        locationGroup.add(machine);

                        // „Ç¶„Çß„Ç§„Éà
                        const weightGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 8);
                        const weightMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                        for(let i = 0; i < 4; i++) {
                            const weight = new THREE.Mesh(weightGeometry, weightMaterial);
                            weight.position.set(
                                Math.cos(i * Math.PI/2) * 1.5,
                                0.2,
                                Math.sin(i * Math.PI/2) * 1.5
                            );
                            locationGroup.add(weight);
                        }
                        break;

                    case "Áî∫„ÅÆÂ∫ÉÂ†¥":
                        // Âô¥Ê∞¥
                        const fountainBaseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.3, 16);
                        const fountainBaseMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                        const fountainBase = new THREE.Mesh(fountainBaseGeometry, fountainBaseMaterial);
                        fountainBase.position.set(0, 0.15, 0);
                        locationGroup.add(fountainBase);

                        const fountainCenterGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                        const fountainCenterMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                        const fountainCenter = new THREE.Mesh(fountainCenterGeometry, fountainCenterMaterial);
                        fountainCenter.position.set(0, 0.8, 0);
                        locationGroup.add(fountainCenter);

                        // „Éô„É≥„ÉÅ
                        for(let i = 0; i < 4; i++) {
                            const benchGeometry = new THREE.BoxGeometry(2, 0.2, 0.5);
                            const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const bench = new THREE.Mesh(benchGeometry, benchMaterial);
                            bench.position.set(
                                Math.cos(i * Math.PI/2) * 3,
                                0.1,
                                Math.sin(i * Math.PI/2) * 3
                            );
                            bench.rotation.y = i * Math.PI/2;
                            locationGroup.add(bench);
                        }
                        break;
                }

                // ÁúãÊùø
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'white';
                context.fillRect(0, 0, 256, 64);
                context.fillStyle = 'black';
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                context.fillText(loc.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const signMaterial = new THREE.MeshBasicMaterial({ map: texture });
                const signGeometry = new THREE.PlaneGeometry(3, 0.75);
                const signMesh = new THREE.Mesh(signGeometry, signMaterial);
                signMesh.position.set(0, 4.5, 3.1);
                locationGroup.add(signMesh);

                // Â†¥ÊâÄ„ÅÆ‰ΩçÁΩÆ„ÇíË®≠ÂÆö
                locationGroup.position.set(loc.x, 0, loc.z);
                scene.add(locationGroup);
                
                locations.push({
                    name: loc.name,
                    position: new THREE.Vector3(loc.x, 0, loc.z),
                    mesh: locationGroup,
                    activities: loc.activities,
                    atmosphere: loc.atmosphere
                });
            });

            // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆËá™ÂÆÖ„Çí‰ΩúÊàê
            agentPersonalities.forEach(agent => {
                const homeGroup = new THREE.Group();
                
                // ÂÆ∂„ÅÆÂü∫Êú¨ÊßãÈÄ†
                const houseGeometry = new THREE.BoxGeometry(4, 3, 4);
                const houseMaterial = new THREE.MeshLambertMaterial({ 
                    color: agent.home.color,
                    emissive: agent.home.color,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const house = new THREE.Mesh(houseGeometry, houseMaterial);
                house.position.set(0, 1.5, 0);
                house.castShadow = true;
                house.receiveShadow = true;
                homeGroup.add(house);

                // Â±ãÊ†π
                const roofGeometry = new THREE.ConeGeometry(3, 2, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    emissive: 0x8B4513,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 4, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                homeGroup.add(roof);

                // ÁúãÊùø
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'white';
                context.fillRect(0, 0, 256, 64);
                context.fillStyle = 'black';
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.fillText(agent.home.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const signMaterial = new THREE.MeshBasicMaterial({ map: texture });
                const signGeometry = new THREE.PlaneGeometry(2, 0.5);
                const signMesh = new THREE.Mesh(signGeometry, signMaterial);
                signMesh.position.set(0, 3.5, 2.1);
                homeGroup.add(signMesh);

                // ÂÆ∂„ÅÆ‰ΩçÁΩÆ„ÇíË®≠ÂÆö
                homeGroup.position.set(agent.home.x, 0, agent.home.z);
                scene.add(homeGroup);
                
                locations.push({
                    name: agent.home.name,
                    position: new THREE.Vector3(agent.home.x, 0, agent.home.z),
                    mesh: homeGroup,
                    activities: ["‰ºëÊÜ©„Åô„Çã", "Áú†„Çã", "Ë™≠Êõ∏„Åô„Çã"],
                    atmosphere: "Èùô„Åã„ÅßËêΩ„Å°ÁùÄ„ÅÑ„ÅüÈõ∞Âõ≤Ê∞ó„ÅÆÂÆ∂",
                    isHome: true,
                    owner: agent.name
                });
            });
        }
        
        // „Éû„Ç¶„Çπ„Ç≥„É≥„Éà„É≠„Éº„É´
        function setupMouseControls() {
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    // „Éû„Ç¶„Çπ„ÅÆÁßªÂãïÊñπÂêë„Å®ÈÄÜÊñπÂêë„Å´„Ç´„É°„É©„ÇíÁßªÂãï
                    camera.position.x -= deltaX * 0.1;
                    camera.position.z -= deltaY * 0.1;
                    camera.lookAt(0, 0, 0);
                }
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            document.addEventListener('mousedown', () => {
                isMouseDown = true;
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            document.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.y = Math.max(10, Math.min(50, camera.position.y));
                camera.lookAt(0, 0, 0);
            });
        }
        
        // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆ‰ΩúÊàê
        function createAgents() {
            agentPersonalities.forEach((data, index) => {
                const agent = new Agent(data, index);
                agents.push(agent);
            });
            updateAgentInfo();
        }
        
        // ÊôÇÈñì„Ç∑„Çπ„ÉÜ„É†
        function updateTime() {
            if (!simulationRunning || simulationPaused) return;
            
            currentTime += timeSpeed;
            if (currentTime >= 24 * 60) {
                currentTime = 0;
            }
            
            const hours = Math.floor(currentTime / 60);
            const minutes = Math.floor(currentTime % 60);
            const timeString = `${hours < 12 ? 'ÂçàÂâç' : 'ÂçàÂæå'} ${hours === 0 ? 12 : hours > 12 ? hours - 12 : hours}:${minutes.toString().padStart(2, '0')}`;
            document.getElementById('time-display').textContent = timeString;
            
            // ÊôÇÈñìÂ∏Ø„Å´„Çà„ÇãÁí∞Â¢É„ÅÆÂ§âÂåñ
            updateEnvironment(hours);
        }
        
        function updateEnvironment(hour) {
            // Á©∫„ÅÆËâ≤„ÇíÊôÇÈñìÂ∏Ø„Å´Âøú„Åò„Å¶Â§âÊõ¥
            let skyColor;
            if (hour < 6 || hour > 20) {
                skyColor = new THREE.Color(0x1a1a2e); // Â§ú
            } else if (hour < 8 || hour > 18) {
                skyColor = new THREE.Color(0xffa500); // ÊúùÂ§ï
            } else {
                skyColor = new THREE.Color(0x87CEEB); // Êòº
            }
            
            scene.background = skyColor;
            //scene.fog.color = skyColor;
        }
        
        // UIÊõ¥Êñ∞
        function updateAgentInfo() {
            const agentsList = document.getElementById('agents-list');
            agentsList.innerHTML = '';
            
            agents.forEach(agent => {
                const agentCard = document.createElement('div');
                agentCard.className = 'agent-card';
                
                // Âü∫Êú¨ÊÉÖÂ†±
                const nameDiv = document.createElement('div');
                nameDiv.className = 'agent-name';
                nameDiv.innerHTML = `
                    <span class="agent-status status-active"></span>
                    ${agent.name} (${agent.age}Ê≠≥)
                    ${agent.isThinking ? '<span class="thinking-indicator"></span>' : ''}
                `;
                agentCard.appendChild(nameDiv);
                
                // ÁèæÂú®„ÅÆÊÉÖÂ†±
                const infoDiv = document.createElement('div');
                infoDiv.innerHTML = `
                    <div class="agent-info-row">üìç Â†¥ÊâÄ: ${agent.currentLocation.name}</div>
                    <div class="agent-info-row">‚ö° ‰ΩìÂäõ: ${Math.round(agent.energy * 100)}%</div>
                    <div class="agent-info-row">üòä Ê∞óÂàÜ: ${agent.mood}</div>
                `;
                agentCard.appendChild(infoDiv);
                
                // ÁèæÂú®„ÅÆÊÄùËÄÉ
                if (agent.currentThought) {
                    const thoughtDiv = document.createElement('div');
                    thoughtDiv.className = 'agent-thought';
                    thoughtDiv.textContent = agent.currentThought;
                    agentCard.appendChild(thoughtDiv);
                }
                
                // ÊúÄËøë„ÅÆË®òÊÜ∂
                if (agent.shortTermMemory.length > 0) {
                    const memoryDiv = document.createElement('div');
                    memoryDiv.className = 'agent-memory';
                    memoryDiv.innerHTML = '<strong>ÊúÄËøë„ÅÆË®òÊÜ∂:</strong>';
                    
                    const recentMemories = agent.shortTermMemory.slice(-3);
                    recentMemories.forEach(memory => {
                        const memoryItem = document.createElement('div');
                        memoryItem.className = 'memory-item';
                        memoryItem.textContent = `‚Ä¢ ${memory.event}`;
                        memoryDiv.appendChild(memoryItem);
                    });
                    
                    agentCard.appendChild(memoryDiv);
                }
                
                // Èñ¢‰øÇÊÄßÊÉÖÂ†±
                const relationshipsDiv = document.createElement('div');
                relationshipsDiv.className = 'relationship-info';
                relationshipsDiv.innerHTML = '<strong>Èñ¢‰øÇÊÄß:</strong>';
                
                let hasRelationships = false;
                agent.relationships.forEach((rel, name) => {
                    if (rel.interactionCount > 0) {
                        hasRelationships = true;
                        const relItem = document.createElement('div');
                        relItem.className = 'relationship-item';
                        relItem.innerHTML = `
                            <span>${name}:</span>
                            <div class="relationship-bar">
                                <div class="relationship-fill" style="width: ${rel.affinity * 100}%"></div>
                            </div>
                        `;
                        relationshipsDiv.appendChild(relItem);
                    }
                });
                
                if (hasRelationships) {
                    agentCard.appendChild(relationshipsDiv);
                }
                
                agentsList.appendChild(agentCard);
            });
        }
        
        // „É≠„Ç∞„Ç∑„Çπ„ÉÜ„É†
        function addLog(message, type = 'info', details = null) {
            const logPanel = document.getElementById('activity-log');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            const time = new Date();
            const timeString = time.toLocaleTimeString('ja-JP', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            let logContent = `<strong>${timeString}</strong> ${message}`;
            
            // Ë©≥Á¥∞ÊÉÖÂ†±„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÊäò„Çä„Åü„Åü„ÅøÂèØËÉΩ„Å™„Çª„ÇØ„Ç∑„Éß„É≥„Å®„Åó„Å¶Ë°®Á§∫
            if (details) {
                const detailsId = `details-${Date.now()}`;
                logContent += `
                    <div class="log-details-toggle" onclick="toggleDetails('${detailsId}')">
                        <span class="toggle-icon">‚ñº</span> Ë©≥Á¥∞„ÇíË¶ã„Çã
                    </div>
                    <div id="${detailsId}" class="log-details" style="display: none;">
                        ${details}
                    </div>
                `;
            }
            
            logEntry.innerHTML = logContent;
            logPanel.insertBefore(logEntry, logPanel.firstChild);
            
            // ÊúÄÂ§ß50‰ª∂„ÅÆ„É≠„Ç∞„Çí‰øùÊåÅ
            while (logPanel.children.length > 50) {
                logPanel.removeChild(logPanel.lastChild);
            }
        }
        
        // „É≠„Ç∞„ÅÆË©≥Á¥∞Ë°®Á§∫Âàá„ÇäÊõø„Åà
        function toggleDetails(detailsId) {
            const details = document.getElementById(detailsId);
            const toggle = details.previousElementSibling;
            const icon = toggle.querySelector('.toggle-icon');
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                icon.textContent = '‚ñ≤';
                toggle.querySelector('span:not(.toggle-icon)').textContent = ' Ë©≥Á¥∞„ÇíÈö†„Åô';
            } else {
                details.style.display = 'none';
                icon.textContent = '‚ñº';
                toggle.querySelector('span:not(.toggle-icon)').textContent = ' Ë©≥Á¥∞„ÇíË¶ã„Çã';
            }
        }
        
        // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆË°åÂãï„É≠„Ç∞„ÇíË®òÈå≤
        function logAgentAction(agent, action, details = null) {
            const actionTypes = {
                'move': 'üö∂ ÁßªÂãï',
                'interact': 'üí¨ ‰ºöË©±',
                'activity': 'üéØ Ê¥ªÂãï',
                'think': 'üí≠ ÊÄùËÄÉ'
            };

            const actionType = actionTypes[action] || action;
            const message = `<span class="agent-name">${agent.name}</span>: ${actionType}`;
            
            if (!details) {
                details = `
                    <div class="log-detail-section">
                        <h4>ÁèæÂú®„ÅÆÁä∂ÊÖã</h4>
                        <p>Â†¥ÊâÄ: ${agent.currentLocation.name}</p>
                        <p>‰ΩìÂäõ: ${Math.round(agent.energy * 100)}%</p>
                        <p>Ê∞óÂàÜ: ${agent.calculateMood()}</p>
                    </div>
                `;
            }
            
            addLog(message, action, details);
        }

        // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆÈñ¢‰øÇÊÄß„É≠„Ç∞„ÇíË®òÈå≤
        function logRelationshipChange(agent1, agent2, changeType, details = null) {
            const relationship = agent1.relationships.get(agent2.name);
            const message = `
                <span class="agent-name">${agent1.name}</span> „Å® 
                <span class="agent-name">${agent2.name}</span> „ÅÆÈñ¢‰øÇÊÄß„ÅåÂ§âÂåñ
            `;
            
            if (!details) {
                details = `
                    <div class="log-detail-section">
                        <h4>Èñ¢‰øÇÊÄß„ÅÆË©≥Á¥∞</h4>
                        <p>Ë¶™ÂØÜÂ∫¶: ${Math.round(relationship.familiarity * 100)}%</p>
                        <p>Â•ΩÊÑüÂ∫¶: ${Math.round(relationship.affinity * 100)}%</p>
                        <p>‰∫§ÊµÅÂõûÊï∞: ${relationship.interactionCount}Âõû</p>
                        <p>ÊúÄÂæå„ÅÆ‰∫§ÊµÅ: ${relationship.lastInteraction ? relationship.lastInteraction.toLocaleString() : '„Å™„Åó'}</p>
                    </div>
                `;
            }
            
            addLog(message, 'relationship', details);
        }
        
        // „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Âà∂Âæ°
        function startSimulation() {
            apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert('OpenAI API„Ç≠„Éº„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }
            
            simulationRunning = true;
            document.getElementById('pauseBtn').disabled = false;
            
            // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆ‰ΩúÊàê
            createAgents();
            
            addLog('<span style="color: #4CAF50;">üé¨ „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÈñãÂßã</span>');
        }
        
        function pauseSimulation() {
            simulationPaused = !simulationPaused;
            document.getElementById('pauseBtn').textContent = simulationPaused ? 'ÂÜçÈñã' : '‰∏ÄÊôÇÂÅúÊ≠¢';
            
            if (simulationPaused) {
                addLog('<span style="color: #FFC107;">‚è∏Ô∏è „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥‰∏ÄÊôÇÂÅúÊ≠¢</span>');
            } else {
                addLog('<span style="color: #4CAF50;">‚ñ∂Ô∏è „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÂÜçÈñã</span>');
            }
        }
        
        function setTimeSpeed() {
            const speeds = [1, 2, 5, 10];
            const currentIndex = speeds.indexOf(timeSpeed);
            const nextIndex = (currentIndex + 1) % speeds.length;
            timeSpeed = speeds[nextIndex];
            document.getElementById('speed').textContent = `${timeSpeed}x`;
        }
        
        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            // ÊôÇÈñì„ÅÆÊõ¥Êñ∞
            updateTime();
            
            // „Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆÊõ¥Êñ∞
            if (agents.length > 0) {
                agents.forEach(agent => {
                    agent.update(deltaTime);
                });
                
                // UIÊõ¥Êñ∞Ôºà1Áßí„Åî„Å®Ôºâ
                if (Math.floor(clock.getElapsedTime()) % 1 === 0) {
                    updateAgentInfo();
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÂØæÂøú
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ÂàùÊúüÂåñ
        init();
    </script>
</body>
</html>